# Security Hardening for VPA-NAP Integration

---
# Enhanced RBAC with Least Privilege Principle
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: vpa-nap-coordinator-minimal
rules:
# VPA read/write access (minimal)
- apiGroups: ["autoscaling.k8s.io"]
  resources: ["verticalpodautoscalers"]
  verbs: ["get", "list", "watch", "patch"]
  resourceNames: []  # Can be restricted to specific VPAs if needed
- apiGroups: ["autoscaling.k8s.io"]
  resources: ["verticalpodautoscalercheckpoints"]
  verbs: ["get", "list", "watch"]

# Custom coordination resources
- apiGroups: ["platform.io"]
  resources: ["vpanapcoordinations"]
  verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]

# Read-only access for monitoring
- apiGroups: [""]
  resources: ["events"]
  verbs: ["get", "list", "watch", "create"]
  resourceNames: []
- apiGroups: [""]
  resources: ["nodes", "pods"]
  verbs: ["get", "list", "watch"]
  resourceNames: []
- apiGroups: ["metrics.k8s.io"]
  resources: ["nodes", "pods"]
  verbs: ["get", "list"]

# Only specific namespaces for enhanced security
- apiGroups: [""]
  resources: ["namespaces"]
  verbs: ["get", "list"]
  resourceNames: ["tenant-dev-*", "tenant-std-*", "tenant-premium-*"]

---
# Service Account with Security Context
apiVersion: v1
kind: ServiceAccount
metadata:
  name: vpa-nap-coordinator-secure
  namespace: platform
  annotations:
    # Azure AD Pod Identity (if using AAD)
    aadpodidbinding: vpa-nap-coordinator
automountServiceAccountToken: true

---
# Least Privilege ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: vpa-nap-coordinator-minimal
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: vpa-nap-coordinator-minimal
subjects:
- kind: ServiceAccount
  name: vpa-nap-coordinator-secure
  namespace: platform

---
# Network Policy for Coordinator Pod
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: vpa-nap-coordinator-netpol
  namespace: platform
spec:
  podSelector:
    matchLabels:
      app: vpa-nap-coordinator
  policyTypes:
  - Ingress
  - Egress
  ingress:
  # Allow prometheus scraping
  - from:
    - namespaceSelector:
        matchLabels:
          name: monitoring
    - podSelector:
        matchLabels:
          app: prometheus
    ports:
    - protocol: TCP
      port: 8080
  egress:
  # Allow Kubernetes API access
  - to:
    - namespaceSelector: {}
      podSelector:
        matchLabels:
          component: kube-apiserver
    ports:
    - protocol: TCP
      port: 443
  # Allow DNS resolution
  - to:
    - namespaceSelector:
        matchLabels:
          name: kube-system
      podSelector:
        matchLabels:
          k8s-app: kube-dns
    ports:
    - protocol: UDP
      port: 53
    - protocol: TCP
      port: 53

---
# Pod Security Policy (if still using PSPs)
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: vpa-nap-coordinator-psp
spec:
  privileged: false
  allowPrivilegeEscalation: false
  requiredDropCapabilities:
    - ALL
  volumes:
    - 'configMap'
    - 'secret'
    - 'projected'
    - 'emptyDir'
  hostNetwork: false
  hostIPC: false
  hostPID: false
  runAsUser:
    rule: 'MustRunAsNonRoot'
  seLinux:
    rule: 'RunAsAny'
  fsGroup:
    rule: 'RunAsAny'
  readOnlyRootFilesystem: true

---
# Pod Security Standards (for Kubernetes 1.23+)
apiVersion: v1
kind: Namespace
metadata:
  name: platform
  labels:
    pod-security.kubernetes.io/enforce: restricted
    pod-security.kubernetes.io/audit: restricted
    pod-security.kubernetes.io/warn: restricted

---
# Admission Controller Webhook for Enhanced Security
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingAdmissionWebhook
metadata:
  name: vpa-nap-security-validator
webhooks:
- name: vpa-security.platform.io
  clientConfig:
    service:
      name: vpa-security-webhook
      namespace: platform
      path: "/validate-vpa"
    caBundle: LS0tLS1CRUdJTi... # Base64 encoded CA certificate
  rules:
  - operations: ["CREATE", "UPDATE"]
    apiGroups: ["autoscaling.k8s.io"]
    apiVersions: ["v1"]
    resources: ["verticalpodautoscalers"]
  admissionReviewVersions: ["v1", "v1beta1"]
  sideEffects: None
  failurePolicy: Fail

---
# Emergency Access Role (Break Glass)
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: vpa-nap-emergency-access
  annotations:
    # Requires approval through PIM/JIT system
    emergency-access: "true"
    approval-required: "platform-security-team"
rules:
- apiGroups: ["*"]
  resources: ["*"]
  verbs: ["*"]
  # This role should only be bound temporarily during incidents

---
# Secure Deployment with Security Context
apiVersion: apps/v1
kind: Deployment
metadata:
  name: vpa-nap-coordinator-secure
  namespace: platform
  labels:
    app: vpa-nap-coordinator
    security.hardened: "true"
spec:
  replicas: 1
  selector:
    matchLabels:
      app: vpa-nap-coordinator
  template:
    metadata:
      labels:
        app: vpa-nap-coordinator
      annotations:
        # Security scanning annotations
        security.scan/last-scan: "2024-01-01T00:00:00Z"
        security.vulnerability/status: "clean"
    spec:
      serviceAccountName: vpa-nap-coordinator-secure
      securityContext:
        runAsNonRoot: true
        runAsUser: 65534  # nobody user
        fsGroup: 65534
        seccompProfile:
          type: RuntimeDefault
      containers:
      - name: coordinator
        image: bitnami/kubectl:latest
        imagePullPolicy: Always
        command: ["/bin/bash"]
        args: ["/scripts/coordinator.sh"]
        securityContext:
          allowPrivilegeEscalation: false
          runAsNonRoot: true
          runAsUser: 65534
          readOnlyRootFilesystem: true
          capabilities:
            drop:
            - ALL
          seccompProfile:
            type: RuntimeDefault
        env:
        - name: CIRCUIT_BREAKER_NODE_CHANGES_THRESHOLD
          valueFrom:
            configMapKeyRef:
              name: vpa-nap-coordinator-config
              key: circuit-breaker-threshold
        - name: CIRCUIT_BREAKER_EVICTIONS_THRESHOLD
          valueFrom:
            configMapKeyRef:
              name: vpa-nap-coordinator-config
              key: eviction-threshold
        - name: COOLDOWN_MINUTES
          valueFrom:
            configMapKeyRef:
              name: vpa-nap-coordinator-config
              key: cooldown-minutes
        # Sensitive configuration from secrets
        - name: WEBHOOK_SECRET
          valueFrom:
            secretKeyRef:
              name: vpa-nap-coordinator-secrets
              key: webhook-secret
        volumeMounts:
        - name: scripts
          mountPath: /scripts
          readOnly: true
        - name: tmp
          mountPath: /tmp
        - name: var-run
          mountPath: /var/run
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 256Mi
        livenessProbe:
          exec:
            command:
            - /bin/bash
            - -c
            - "pgrep -f coordinator.sh"
          initialDelaySeconds: 30
          periodSeconds: 30
          failureThreshold: 3
        readinessProbe:
          exec:
            command:
            - /bin/bash
            - -c
            - "test -f /tmp/coordinator-ready"
          initialDelaySeconds: 5
          periodSeconds: 10
          failureThreshold: 3
      volumes:
      - name: scripts
        configMap:
          name: vpa-nap-coordinator-scripts
          defaultMode: 0555  # Read and execute only
      - name: tmp
        emptyDir: {}
      - name: var-run
        emptyDir: {}
      # Security hardening
      automountServiceAccountToken: true
      hostNetwork: false
      hostPID: false
      hostIPC: false

---
# Secure Configuration (non-sensitive)
apiVersion: v1
kind: ConfigMap
metadata:
  name: vpa-nap-coordinator-config
  namespace: platform
data:
  circuit-breaker-threshold: "5"
  eviction-threshold: "20"
  cooldown-minutes: "30"
  log-level: "info"
  enable-metrics: "true"

---
# Secrets for Sensitive Configuration
apiVersion: v1
kind: Secret
metadata:
  name: vpa-nap-coordinator-secrets
  namespace: platform
type: Opaque
data:
  # Example webhook secret (base64 encoded)
  webhook-secret: YWRtaW4tc2VjcmV0LWtleQ==
  # TLS certificates for webhook communication
  tls.crt: LS0tLS1CRUdJTi...
  tls.key: LS0tLS1CRUdJTi...

---
# Monitoring RBAC for Security Events
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: platform
  name: vpa-security-monitor
rules:
- apiGroups: [""]
  resources: ["events"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["platform.io"]
  resources: ["vpanapcoordinations"]
  verbs: ["get", "list", "watch"]

---
# Security Event Monitor Service Account
apiVersion: v1
kind: ServiceAccount
metadata:
  name: vpa-security-monitor
  namespace: platform

---
# Role Binding for Security Monitoring
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: vpa-security-monitor
  namespace: platform
subjects:
- kind: ServiceAccount
  name: vpa-security-monitor
  namespace: platform
roleRef:
  kind: Role
  name: vpa-security-monitor
  apiGroup: rbac.authorization.k8s.io

---
# Security Monitoring CronJob
apiVersion: batch/v1
kind: CronJob
metadata:
  name: vpa-security-audit
  namespace: platform
spec:
  schedule: "0 */6 * * *"  # Every 6 hours
  jobTemplate:
    spec:
      template:
        spec:
          serviceAccountName: vpa-security-monitor
          securityContext:
            runAsNonRoot: true
            runAsUser: 65534
            fsGroup: 65534
          containers:
          - name: security-audit
            image: bitnami/kubectl:latest
            securityContext:
              allowPrivilegeEscalation: false
              runAsNonRoot: true
              runAsUser: 65534
              readOnlyRootFilesystem: true
              capabilities:
                drop:
                - ALL
            command: ["/bin/bash"]
            args:
            - -c
            - |
              echo "Starting VPA-NAP security audit..."
              
              # Check for unauthorized VPA modifications
              kubectl get events --all-namespaces \
                --field-selector reason=VPAModified \
                --output json | \
                jq '.items[] | select(.metadata.creationTimestamp > (now - 86400 | todate))'
              
              # Check for suspicious coordination resource changes
              kubectl get vpanapcoordinations --all-namespaces \
                -o json | \
                jq '.items[] | select(.status.conflictsDetected > 10)'
              
              # Audit RBAC changes
              kubectl get events --all-namespaces \
                --field-selector reason=ClusterRoleBindingModified \
                --output json | \
                jq '.items[] | select(.involvedObject.name | contains("vpa-nap"))'
              
              echo "Security audit completed."
            resources:
              requests:
                cpu: 50m
                memory: 64Mi
              limits:
                cpu: 200m
                memory: 128Mi
          restartPolicy: OnFailure

---
# Emergency Response ClusterRole (Temporary Use Only)
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: vpa-nap-emergency-responder
  annotations:
    emergency-use-only: "true"
    max-binding-duration: "2h"
    approval-required: "security-team"
rules:
# Emergency VPA disable capability
- apiGroups: ["autoscaling.k8s.io"]
  resources: ["verticalpodautoscalers"]
  verbs: ["get", "list", "patch", "delete"]
# Emergency coordination resource management
- apiGroups: ["platform.io"]
  resources: ["vpanapcoordinations"]
  verbs: ["get", "list", "patch", "delete"]
# Emergency deployment scaling
- apiGroups: ["apps"]
  resources: ["deployments", "replicasets"]
  verbs: ["get", "list", "patch", "scale"]
# Emergency event creation
- apiGroups: [""]
  resources: ["events"]
  verbs: ["create"]

---
# Multi-Person Authorization for Emergency Access
apiVersion: v1
kind: ConfigMap
metadata:
  name: emergency-access-policy
  namespace: platform
data:
  policy.yaml: |
    emergencyAccess:
      approvalRequired: 2
      approvers:
        - platform-security-team@company.com
        - platform-engineering-lead@company.com
        - sre-manager@company.com
      maxDuration: "2h"
      auditRequired: true
      notificationChannels:
        - slack: "#security-alerts"
        - email: "security-team@company.com"
      approvalWorkflow:
        - step: "Initial Request"
          approver: "requester"
          evidence: "incident-ticket-url"
        - step: "Security Review"
          approver: "security-team"
          criteria: "security-impact-assessment"
        - step: "Engineering Approval" 
          approver: "engineering-lead"
          criteria: "technical-necessity"